import chalk from 'chalk';
import { parseISO } from 'date-fns';

const DEFAULT_BACKOFF_MAX_RETRIES = 5;
const BASE_DELAY_MS = 1000; // Base delay in milliseconds
class ExponentialBackoff {
    constructor(apiKey, debug, maxRetries = DEFAULT_BACKOFF_MAX_RETRIES) {
        this.maxRetries = maxRetries;
        this.retryCount = 1;
        this._apiKey = apiKey;
        this._debug = debug;
    }
    async backOff(url) {
        try {
            let startTime;
            if (this._debug) {
                startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
            }
            const response = await fetch(url, {
                headers: {
                    "Authorization": `Bearer ${this._apiKey}`,
                    "X-Requested-With": userAgent
                }
            });
            debugOutput(response.url, response.status, startTime);
            if (response.status === 429) {
                throw new Error(`Received status code: ${response.status}`);
            }
            else {
                return response.json();
            }
        }
        catch (error) {
            if (error.message.includes(`Received status code: 429`) && this.retryCount < this.maxRetries) {
                this.retryCount++;
                const delayMs = Math.pow(2, this.retryCount) * BASE_DELAY_MS;
                await new Promise((resolve) => setTimeout(resolve, delayMs));
                return this.backOff(url);
            }
            return Promise.reject(new Error(`Max retries exceeded: ${this.maxRetries}`));
        }
    }
    // to reset the numAttempts for another request
    setNumAttempts(retryCount) {
        this.retryCount = retryCount;
    }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

class Node {
	/// value;
	/// next;

	constructor(value) {
		this.value = value;

		// TODO: Remove this when targeting Node.js 12.
		this.next = undefined;
	}
}

let Queue$1 = class Queue {
	// TODO: Use private class fields when targeting Node.js 12.
	// #_head;
	// #_tail;
	// #_size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this._head) {
			this._tail.next = node;
			this._tail = node;
		} else {
			this._head = node;
			this._tail = node;
		}

		this._size++;
	}

	dequeue() {
		const current = this._head;
		if (!current) {
			return;
		}

		this._head = this._head.next;
		this._size--;
		return current.value;
	}

	clear() {
		this._head = undefined;
		this._tail = undefined;
		this._size = 0;
	}

	get size() {
		return this._size;
	}

	* [Symbol.iterator]() {
		let current = this._head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}
};

var yoctoQueue = Queue$1;

const Queue = yoctoQueue;

const pLimit = concurrency => {
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = new Queue();
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.size > 0) {
			queue.dequeue()();
		}
	};

	const run = async (fn, resolve, ...args) => {
		activeCount++;

		const result = (async () => fn(...args))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (fn, resolve, ...args) => {
		queue.enqueue(run.bind(null, fn, resolve, ...args));

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// when the run function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency && queue.size > 0) {
				queue.dequeue()();
			}
		})();
	};

	const generator = (fn, ...args) => new Promise(resolve => {
		enqueue(fn, resolve, ...args);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.size
		},
		clearQueue: {
			value: () => {
				queue.clear();
			}
		}
	});

	return generator;
};

var pLimit_1 = pLimit;

var pLimit$1 = /*@__PURE__*/getDefaultExportFromCjs(pLimit_1);

function checkAndModifyResponse(jsonObj) {
    for (const key in jsonObj) {
        if (key === 'next_update_at') {
            delete jsonObj[key];
        }
        else if (typeof jsonObj[key] === 'object') {
            checkAndModifyResponse(jsonObj[key]);
        }
    }
}
async function debugOutput(url, responseStatus, startTime) {
    let endTime;
    let elapsedTime;
    if (startTime === undefined) {
        return;
    }
    if (typeof startTime !== 'number') {
        endTime = process.hrtime(startTime);
        elapsedTime = (endTime[0] * 1000 + endTime[1] / 1e6);
    }
    else {
        endTime = performance.now();
        elapsedTime = endTime - startTime;
    }
    console.log(`${chalk.red("[DEBUG]")}` + " |" + ` Request URL: ${chalk.yellow(url)}` + " |" + ` Response code: ${responseStatus !== 200 ? chalk.red(responseStatus) : chalk.green(responseStatus)}` + " |" + ` Response time: ${chalk.cyan(elapsedTime.toFixed(2) + "ms")}`);
}
async function* paginateEndpoint$1(url, apiKey, urlsParams, dataClassConstructor, debug, threadCount) {
    let hasNext = true;
    let response;
    let data;
    const backoff = new ExponentialBackoff(apiKey, debug);
    let page_number = 0;
    const LIMIT = pLimit$1(threadCount);
    while (hasNext) {
        try {
            let startTime;
            if (debug) {
                startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
            }
            response = await LIMIT(() => fetch(urlsParams.get("page-number") ? `${url}?${urlsParams}` : `${url}?${urlsParams}&page-number=${page_number}`, {
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "X-Requested-With": userAgent
                }
            }));
            debugOutput(response.url, response.status, startTime);
            if (response.status === 429) {
                try {
                    data = await LIMIT(() => backoff.backOff(response.url));
                }
                catch (error) {
                    hasNext = false;
                    throw new Error(`An error occurred ${response.status}: ${error.message}`);
                }
            }
            else {
                data = await response.json();
            }
            for (const tx of data.data.items) {
                const dataClass = new dataClassConstructor(tx);
                checkAndModifyResponse(dataClass);
                yield dataClass;
            }
            backoff.setNumAttempts(1);
            if (!data.error) {
                if ((data.data !== null) && data.data.pagination !== null && data.data.pagination.has_more === false) {
                    hasNext = false;
                }
                if (urlsParams.get("page-number")) {
                    const next_page = parseInt(urlsParams.get("page-number")) + 1;
                    urlsParams.set("page-number", next_page.toString());
                }
                else {
                    page_number = page_number + 1;
                }
            }
            else {
                hasNext = false;
            }
        }
        catch (error) {
            hasNext = false;
            if (error.message.includes("An error occurred 429")) {
                throw new Error(error.message);
            }
            throw new Error(`An error occurred ${data ? data.error_code : response.status}: ${data ? data.error_message : "401 Authorization Required"}`);
        }
    }
}

class ApprovalsResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokensApprovalItem(itemData)) : null;
    }
}
class TokensApprovalItem {
    constructor(data) {
        this.token_address = data.token_address;
        this.token_address_label = data.token_address_label;
        this.ticker_symbol = data.ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_quote = data.balance_quote;
        this.pretty_balance_quote = data.pretty_balance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.spenders = data.spenders && data.spenders !== null ? data.spenders.map((itemData) => new TokenSpenderItem(itemData)) : null;
    }
}
class TokenSpenderItem {
    constructor(data) {
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.spender_address = data.spender_address;
        this.spender_address_label = data.spender_address_label;
        this.allowance = data.allowance;
        this.allowance_quote = data.allowance_quote;
        this.pretty_allowance_quote = data.pretty_allowance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.risk_factor = data.risk_factor;
    }
}
/**
 * Approvals API
 *
 */
class SecurityService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to get a list of approvals across all token contracts categorized by spenders for a wallet’s assets.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getApprovals(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/approvals/${walletAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ApprovalsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}

class BalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new BalanceItem(itemData)) : null;
    }
}
class BalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.last_transferred_at = data.last_transferred_at && data.last_transferred_at !== null ? parseISO(data.last_transferred_at.toString()) : null;
        this.native_token = data.native_token;
        this.type = data.type;
        this.is_spam = data.is_spam;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h && data.balance_24h !== null ? BigInt(data.balance_24h) : null;
        this.quote_rate = data.quote_rate;
        this.quote_rate_24h = data.quote_rate_24h;
        this.quote = data.quote;
        this.quote_24h = data.quote_24h;
        this.pretty_quote = data.pretty_quote;
        this.pretty_quote_24h = data.pretty_quote_24h;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new NftData$1(itemData)) : null;
    }
}
let NftData$1 = class NftData {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_url = data.token_url;
        this.original_owner = data.original_owner;
        this.asset_cached = data.asset_cached;
        this.image_cached = data.image_cached;
        this.external_data = data.external_data && data.external_data !== null ? new NftExternalData$1(data.external_data) : null;
    }
};
let NftExternalData$1 = class NftExternalData {
    constructor(data) {
        this.name = data.name;
        this.description = data.description;
        this.asset_url = data.asset_url;
        this.asset_file_extension = data.asset_file_extension;
        this.asset_mime_type = data.asset_mime_type;
        this.asset_size_bytes = data.asset_size_bytes;
        this.image = data.image;
        this.image_256 = data.image_256;
        this.image_512 = data.image_512;
        this.image_1024 = data.image_1024;
        this.animation_url = data.animation_url;
        this.external_url = data.external_url;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftCollectionAttribute$1(itemData)) : null;
    }
};
let NftCollectionAttribute$1 = class NftCollectionAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.value = data.value;
    }
};
class PortfolioResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PortfolioItem(itemData)) : null;
    }
}
class PortfolioItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.logo_url = data.logo_url;
        this.holdings = data.holdings && data.holdings !== null ? data.holdings.map((itemData) => new HoldingItem(itemData)) : null;
    }
}
class HoldingItem {
    constructor(data) {
        this.quote_rate = data.quote_rate;
        this.timestamp = data.timestamp && data.timestamp !== null ? parseISO(data.timestamp.toString()) : null;
        this.close = data.close && data.close !== null ? new OhlcItem(data.close) : null;
        this.high = data.high && data.high !== null ? new OhlcItem(data.high) : null;
        this.low = data.low && data.low !== null ? new OhlcItem(data.low) : null;
        this.open = data.open && data.open !== null ? new OhlcItem(data.open) : null;
    }
}
class OhlcItem {
    constructor(data) {
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
    }
}
class BlockTransactionWithContractTransfers {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.transfers = data.transfers && data.transfers !== null ? data.transfers.map((itemData) => new TokenTransferItem(itemData)) : null;
    }
}
class TokenTransferItem {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.transfer_type = data.transfer_type;
        this.delta = data.delta && data.delta !== null ? BigInt(data.delta) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.delta_quote = data.delta_quote;
        this.pretty_delta_quote = data.pretty_delta_quote;
        this.balance_quote = data.balance_quote;
        this.method_calls = data.method_calls && data.method_calls !== null ? data.method_calls.map((itemData) => new MethodCallsForTransfers(itemData)) : null;
    }
}
class MethodCallsForTransfers {
    constructor(data) {
        this.sender_address = data.sender_address;
        this.method = data.method;
    }
}
class TokenHolder {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.address = data.address;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.block_height = data.block_height;
    }
}
class HistoricalBalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new HistoricalBalanceItem(itemData)) : null;
    }
}
class HistoricalBalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.block_height = data.block_height;
        this.last_transferred_block_height = data.last_transferred_block_height;
        this.last_transferred_at = data.last_transferred_at && data.last_transferred_at !== null ? parseISO(data.last_transferred_at.toString()) : null;
        this.native_token = data.native_token;
        this.type = data.type;
        this.is_spam = data.is_spam;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new NftData$1(itemData)) : null;
    }
}
/**
 * Balances APIs
 *
 */
class BalanceService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch the native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address. Response includes spot prices and other metadata.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *
     */
    async getTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.nft !== undefined) {
                    urlParams.append("nft", queryParamOpts?.nft.toString());
                }
                if (queryParamOpts?.noNftFetch !== undefined) {
                    urlParams.append("no-nft-fetch", queryParamOpts?.noNftFetch.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BalancesResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render a daily portfolio balance for an address broken down by the token. The timeframe is user-configurable, defaults to 30 days.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalPortfolioForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `days`: The number of days to return data for. Defaults to 30 days.
     *
     */
    async getHistoricalPortfolioForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/portfolio_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PortfolioResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render the transfer-in and transfer-out of a token along with historical prices from an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetErc20TransfersForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `contractAddress`: The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `startingBlock`: The block height to start from, defaults to `0`.
     *   - `endingBlock`: The block height to end at, defaults to current block height.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getErc20TransfersForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.contractAddress !== undefined) {
                    urlParams.append("contract-address", queryParamOpts?.contractAddress.toString());
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transfers_v2/`, this.apiKey, urlParams, BlockTransactionWithContractTransfers, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get a list of all the token holders for a specified ERC20 or ERC721 token. Returns historic token holders when block-height is set (defaults to `latest`). Useful for building pie charts of token holders.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenHoldersV2ForTokenAddressQueryParamOpts} queryParamOpts
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `pageSize`: Number of items per page. Note: Currently, only values of `100` and `1000` are supported. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getTokenHoldersV2ForTokenAddress(chainName, tokenAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/tokens/${tokenAddress}/token_holders_v2/`, this.apiKey, urlParams, TokenHolder, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to fetch the historical native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address at a given block height or date. Response includes daily prices and other metadata.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async getHistoricalTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.nft !== undefined) {
                    urlParams.append("nft", queryParamOpts?.nft.toString());
                }
                if (queryParamOpts?.noNftFetch !== undefined) {
                    urlParams.append("no-nft-fetch", queryParamOpts?.noNftFetch.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/historical_balances/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new HistoricalBalancesResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}

class BlockResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Block(itemData)) : null;
    }
}
class Block {
    constructor(data) {
        this.signed_at = data.signed_at && data.signed_at !== null ? parseISO(data.signed_at.toString()) : null;
        this.height = data.height;
    }
}
class ResolvedAddress {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ResolvedAddressItem(itemData)) : null;
    }
}
class ResolvedAddressItem {
    constructor(data) {
        this.address = data.address;
        this.name = data.name;
    }
}
class GetLogsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new GetLogsEvent(itemData)) : null;
    }
}
class GetLogsEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem$2(data.decoded) : null;
    }
}
let DecodedItem$2 = class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param$2(itemData)) : null;
    }
};
let Param$2 = class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
};
let LogEvent$2 = class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem$2(data.decoded) : null;
    }
};
class AllChainsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainItem(itemData)) : null;
    }
}
class ChainItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.db_schema_name = data.db_schema_name;
        this.label = data.label;
        this.category_label = data.category_label;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.appchain_of = data.appchain_of && data.appchain_of !== null ? new ChainItem(data.appchain_of) : null;
    }
}
class AllChainsStatusResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainStatusItem(itemData)) : null;
    }
}
class ChainStatusItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.synced_block_height = data.synced_block_height;
        this.synced_blocked_signed_at = data.synced_blocked_signed_at && data.synced_blocked_signed_at !== null ? parseISO(data.synced_blocked_signed_at.toString()) : null;
        this.has_data = data.has_data;
    }
}
class ChainActivityResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainActivityEvent(itemData)) : null;
    }
}
class ChainActivityEvent extends ChainItem {
    constructor(data) {
        super(data);
        this.last_seen_at = data.last_seen_at && data.last_seen_at !== null ? parseISO(data.last_seen_at.toString()) : null;
    }
}
/**
 * Class A - Base
 *
 */
class BaseService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch and render a single block for a block explorer.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHeight - The block height or `latest` for the latest block available.
     *
     */
    async getBlock(chainName, blockHeight) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_v2/${blockHeight}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BlockResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to resolve ENS, RNS and Unstoppable Domains addresses.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getResolvedAddress(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/resolve_address/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ResolvedAddress(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getBlockHeights(chainName, startDate, endDate, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/`, this.apiKey, urlParams, Block, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs of the latest block, or for a range of blocks. Includes sender contract metadata as well as decoded logs.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetLogsQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `address`: The address of the log events sender contract.
     *   - `topics`: The topic hash(es) to retrieve logs with.
     *   - `blockHash`: The block hash to retrieve logs for.
     *   - `skipDecode`: Omit decoded log events.
     *
     */
    async getLogs(chainName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.address !== undefined) {
                    urlParams.append("address", queryParamOpts?.address.toString());
                }
                if (queryParamOpts?.topics !== undefined) {
                    urlParams.append("topics", queryParamOpts?.topics.toString());
                }
                if (queryParamOpts?.blockHash !== undefined) {
                    urlParams.append("block-hash", queryParamOpts?.blockHash.toString());
                }
                if (queryParamOpts?.skipDecode !== undefined) {
                    urlParams.append("skip-decode", queryParamOpts?.skipDecode.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new GetLogsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByAddress(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/`, this.apiKey, urlParams, LogEvent$2, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByTopicHash(chainName, topicHash, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.secondaryTopics !== undefined) {
                    urlParams.append("secondary-topics", queryParamOpts?.secondaryTopics.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/`, this.apiKey, urlParams, LogEvent$2, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to build internal dashboards for all supported chains on Covalent.
     *
     *
     */
    async getAllChains() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build internal status dashboards of all supported chains.
     *
     *
     */
    async getAllChainStatus() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/status/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsStatusResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to locate chains which an address is active on with a single API call.
     *
     * @param {string} walletAddress - The requested wallet address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAddressActivityQueryParamOpts} queryParamOpts
     *   - `testnets`: Set to true to include testnets with activity in the response. By default, it's set to `false` and only returns mainnet activity.
     *
     */
    async getAddressActivity(walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.testnets !== undefined) {
                    urlParams.append("testnets", queryParamOpts?.testnets.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/address/${walletAddress}/activity/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ChainActivityResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}

class ChainCollectionItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.is_spam = data.is_spam;
        this.token_total_supply = data.token_total_supply;
        this.cached_metadata_count = data.cached_metadata_count;
        this.cached_asset_count = data.cached_asset_count;
        this.last_scraped_at = data.last_scraped_at && data.last_scraped_at !== null ? parseISO(data.last_scraped_at.toString()) : null;
    }
}
let Pagination$1 = class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
};
class NftAddressBalanceNftResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTokenContractBalanceItem(itemData)) : null;
    }
}
class NftTokenContractBalanceItem {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.is_spam = data.is_spam;
        this.last_transfered_at = data.last_transfered_at && data.last_transfered_at !== null ? parseISO(data.last_transfered_at.toString()) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h;
        this.type = data.type;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new NftData(itemData)) : null;
    }
}
class NftData {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_url = data.token_url;
        this.original_owner = data.original_owner;
        this.asset_cached = data.asset_cached;
        this.image_cached = data.image_cached;
        this.external_data = data.external_data && data.external_data !== null ? new NftExternalData(data.external_data) : null;
    }
}
class NftExternalData {
    constructor(data) {
        this.name = data.name;
        this.description = data.description;
        this.asset_url = data.asset_url;
        this.asset_file_extension = data.asset_file_extension;
        this.asset_mime_type = data.asset_mime_type;
        this.asset_size_bytes = data.asset_size_bytes;
        this.image = data.image;
        this.image_256 = data.image_256;
        this.image_512 = data.image_512;
        this.image_1024 = data.image_1024;
        this.animation_url = data.animation_url;
        this.external_url = data.external_url;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftCollectionAttribute(itemData)) : null;
    }
}
class NftCollectionAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.value = data.value;
    }
}
class NftMetadataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTokenContract(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$1(data.pagination) : null;
    }
}
class NftTokenContract {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.is_spam = data.is_spam;
        this.type = data.type;
        this.nft_data = data.nft_data && data.nft_data !== null ? new NftData(data.nft_data) : null;
    }
}
class NftTransactionsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTransaction(itemData)) : null;
    }
}
class NftTransaction {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.logo_url = data.logo_url;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.is_spam = data.is_spam;
        this.nft_transactions = data.nft_transactions && data.nft_transactions !== null ? data.nft_transactions.map((itemData) => new NftTransactionItem(itemData)) : null;
    }
}
class NftTransactionItem {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.log_events = data.log_events && data.log_events !== null ? data.log_events.map((itemData) => new LogEvent$1(itemData)) : null;
    }
}
let LogEvent$1 = class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem$1(data.decoded) : null;
    }
};
let DecodedItem$1 = class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param$1(itemData)) : null;
    }
};
let Param$1 = class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
};
class NftCollectionTraitsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTrait(itemData)) : null;
    }
}
class NftTrait {
    constructor(data) {
        this.name = data.name;
    }
}
class NftCollectionAttributesForTraitResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftSummaryAttribute(itemData)) : null;
    }
}
class NftSummaryAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.unique_values = data.unique_values;
        this.values = data.values && data.values !== null ? data.values.map((itemData) => new NftAttribute(itemData)) : null;
    }
}
class NftAttribute {
    constructor(data) {
        this.value = data.value;
        this.count = data.count;
    }
}
class NftCollectionTraitSummaryResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTraitSummary(itemData)) : null;
    }
}
class NftTraitSummary {
    constructor(data) {
        this.name = data.name;
        this.value_type = data.value_type;
        this.value_numeric = data.value_numeric && data.value_numeric !== null ? new NftTraitNumeric(data.value_numeric) : null;
        this.value_string = data.value_string && data.value_string !== null ? new NftTraitString(data.value_string) : null;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftSummaryAttribute(itemData)) : null;
    }
}
class NftTraitNumeric {
    constructor(data) {
        this.min = data.min;
        this.max = data.max;
    }
}
class NftTraitString {
    constructor(data) {
        this.value = data.value;
        this.token_count = data.token_count;
        this.trait_percentage = data.trait_percentage;
    }
}
class NftOwnershipForCollectionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.collection = data.collection;
        this.is_spam = data.is_spam;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftOwnershipForCollectionItem(itemData)) : null;
    }
}
class NftOwnershipForCollectionItem {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.supports_erc = data.supports_erc;
        this.last_transfered_at = data.last_transfered_at && data.last_transfered_at !== null ? parseISO(data.last_transfered_at.toString()) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h;
        this.type = data.type;
        this.nft_data = data.nft_data && data.nft_data !== null ? new NftData(data.nft_data) : null;
    }
}
/**
 * NFT APIs
 *
 */
class NftService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async *getChainCollections(chainName, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/nft/collections/`, this.apiKey, urlParams, ChainCollectionItem, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to render the NFTs (including ERC721 and ERC1155) held by an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftsForAddressQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftsForAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_nft/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftAddressBalanceNftResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async *getTokenIdsForContractWithMetadata(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.traitsFilter !== undefined) {
                    urlParams.append("traits-filter", queryParamOpts?.traitsFilter.toString());
                }
                if (queryParamOpts?.valuesFilter !== undefined) {
                    urlParams.append("values-filter", queryParamOpts?.valuesFilter.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/`, this.apiKey, urlParams, NftTokenContract, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get a single NFT metadata by token ID from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftMetadataForGivenTokenIdForContractQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftMetadataForGivenTokenIdForContract(chainName, contractAddress, tokenId, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMetadataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all transactions of an NFT token. Useful for building a transaction history table or price chart.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftTransactionsForContractTokenIdQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async getNftTransactionsForContractTokenId(chainName, contractAddress, tokenId, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/tokens/${contractAddress}/nft_transactions/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftTransactionsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the traits of a collection as seen in rarity calculators.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTraitsForCollection(chainName, collectionContract) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionTraitsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the count of unique values for traits within an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} trait - The requested trait.
     *
     */
    async getAttributesForTraitInCollection(chainName, collectionContract, trait) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/${trait}/attributes/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionAttributesForTraitResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to calculate rarity scores for a collection based on its traits.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getCollectionTraitsSummary(chainName, collectionContract) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits_summary/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionTraitSummaryResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to verify ownership of NFTs (including ERC-721 and ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address.
     *
     */
    async checkOwnershipInNft(chainName, walletAddress, collectionContract) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftOwnershipForCollectionResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to verify ownership of a specific token (ERC-721 or ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     *
     */
    async checkOwnershipInNftForSpecificTokenId(chainName, walletAddress, collectionContract, tokenId) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/token/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftOwnershipForCollectionResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}

class TokenPricesResponse {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.update_at = data.update_at && data.update_at !== null ? parseISO(data.update_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.prices = data.prices && data.prices !== null ? data.prices.map((itemData) => new Price(itemData)) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Price(itemData)) : null;
    }
}
class Price {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.price = data.price;
        this.pretty_price = data.pretty_price;
        this.contract_metadata = data.contract_metadata && data.contract_metadata !== null ? new ContractMetadata$1(data.contract_metadata) : null;
    }
}
let ContractMetadata$1 = class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
};
class PricingService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to get historic prices of a token between date ranges. Supports native tokens.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} quoteCurrency - The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     * @param {string} contractAddress - Contract address for the token. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically. Supports multiple contract addresses separated by commas.
     * @param {GetTokenPricesQueryParamOpts} queryParamOpts
     *   - `from`: The start day of the historical price range (YYYY-MM-DD).
     *   - `to`: The end day of the historical price range (YYYY-MM-DD).
     *   - `pricesAtAsc`: Sort the prices in chronological ascending order. By default, it's set to `false` and returns prices in chronological descending order.
     *
     */
    async getTokenPrices(chainName, quoteCurrency, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.from !== undefined) {
                    urlParams.append("from", queryParamOpts?.from.toString());
                }
                if (queryParamOpts?.to !== undefined) {
                    urlParams.append("to", queryParamOpts?.to.toString());
                }
                if (queryParamOpts?.pricesAtAsc !== undefined) {
                    urlParams.append("prices-at-asc", queryParamOpts?.pricesAtAsc.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/pricing/historical_by_addresses_v2/${chainName}/${quoteCurrency}/${contractAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const res = [];
                data.data.forEach((e) => {
                    const dataClass = new TokenPricesResponse(e);
                    checkAndModifyResponse(dataClass);
                    res.push(dataClass);
                });
                success = true;
                return {
                    data: res,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}

class TransactionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
}
class Transaction {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.from_address = data.from_address;
        this.miner_address = data.miner_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata(data.gas_metadata) : null;
        this.dex_details = data.dex_details && data.dex_details !== null ? new DexReport(data.dex_details) : null;
        this.nft_sale_details = data.nft_sale_details && data.nft_sale_details !== null ? new NftSalesReport(data.nft_sale_details) : null;
        this.lending_details = data.lending_details && data.lending_details !== null ? new LendingReport(data.lending_details) : null;
        this.log_events = data.log_events && data.log_events !== null ? data.log_events.map((itemData) => new LogEvent(itemData)) : null;
    }
}
class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class DexReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.protocol_name = data.protocol_name;
        this.protocol_address = data.protocol_address;
        this.protocol_logo_url = data.protocol_logo_url;
        this.aggregator_name = data.aggregator_name;
        this.aggregator_address = data.aggregator_address;
        this.version = data.version;
        this.fork_version = data.fork_version;
        this.fork = data.fork;
        this.event = data.event;
        this.pair_address = data.pair_address;
        this.pair_lp_fee_bps = data.pair_lp_fee_bps;
        this.lp_token_address = data.lp_token_address;
        this.lp_token_ticker = data.lp_token_ticker;
        this.lp_token_num_decimals = data.lp_token_num_decimals;
        this.lp_token_name = data.lp_token_name;
        this.lp_token_value = data.lp_token_value;
        this.exchange_rate_usd = data.exchange_rate_usd;
        this.token_0_address = data.token_0_address;
        this.token_0_ticker = data.token_0_ticker;
        this.token_0_num_decimals = data.token_0_num_decimals;
        this.token_0_name = data.token_0_name;
        this.token_1_address = data.token_1_address;
        this.token_1_ticker = data.token_1_ticker;
        this.token_1_num_decimals = data.token_1_num_decimals;
        this.token_1_name = data.token_1_name;
        this.token_0_amount = data.token_0_amount;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_0_usd_quote = data.token_0_usd_quote;
        this.pretty_token_0_usd_quote = data.pretty_token_0_usd_quote;
        this.token_0_logo_url = data.token_0_logo_url;
        this.token_1_amount = data.token_1_amount;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.token_1_usd_quote = data.token_1_usd_quote;
        this.pretty_token_1_usd_quote = data.pretty_token_1_usd_quote;
        this.token_1_logo_url = data.token_1_logo_url;
        this.sender = data.sender;
        this.recipient = data.recipient;
    }
}
class NftSalesReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.topic0 = data.topic0;
        this.protocol_contract_address = data.protocol_contract_address;
        this.protocol_name = data.protocol_name;
        this.protocol_logo_url = data.protocol_logo_url;
        this.to = data.to;
        this.from = data.from;
        this.maker = data.maker;
        this.taker = data.taker;
        this.token_id = data.token_id;
        this.collection_address = data.collection_address;
        this.collection_name = data.collection_name;
        this.token_address = data.token_address;
        this.token_name = data.token_name;
        this.ticker_symbol = data.ticker_symbol;
        this.num_decimals = data.num_decimals;
        this.contract_quote_rate = data.contract_quote_rate;
        this.nft_token_price = data.nft_token_price;
        this.nft_token_price_usd = data.nft_token_price_usd;
        this.pretty_nft_token_price_usd = data.pretty_nft_token_price_usd;
        this.nft_token_price_native = data.nft_token_price_native;
        this.pretty_nft_token_price_native = data.pretty_nft_token_price_native;
        this.token_count = data.token_count;
        this.num_token_ids_sold_per_sale = data.num_token_ids_sold_per_sale;
        this.num_token_ids_sold_per_tx = data.num_token_ids_sold_per_tx;
        this.num_collections_sold_per_sale = data.num_collections_sold_per_sale;
        this.num_collections_sold_per_tx = data.num_collections_sold_per_tx;
        this.trade_type = data.trade_type;
        this.trade_group_type = data.trade_group_type;
    }
}
class LendingReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.protocol_name = data.protocol_name;
        this.protocol_address = data.protocol_address;
        this.protocol_logo_url = data.protocol_logo_url;
        this.version = data.version;
        this.fork = data.fork;
        this.fork_version = data.fork_version;
        this.event = data.event;
        this.lp_token_name = data.lp_token_name;
        this.lp_decimals = data.lp_decimals;
        this.lp_ticker_symbol = data.lp_ticker_symbol;
        this.lp_token_address = data.lp_token_address;
        this.lp_token_amount = data.lp_token_amount;
        this.lp_token_price = data.lp_token_price;
        this.exchange_rate = data.exchange_rate;
        this.exchange_rate_usd = data.exchange_rate_usd;
        this.token_name_in = data.token_name_in;
        this.token_decimal_in = data.token_decimal_in;
        this.token_address_in = data.token_address_in;
        this.token_ticker_in = data.token_ticker_in;
        this.token_logo_in = data.token_logo_in;
        this.token_amount_in = data.token_amount_in;
        this.amount_in_usd = data.amount_in_usd;
        this.pretty_amount_in_usd = data.pretty_amount_in_usd;
        this.token_name_out = data.token_name_out;
        this.token_decimals_out = data.token_decimals_out;
        this.token_address_out = data.token_address_out;
        this.token_ticker_out = data.token_ticker_out;
        this.token_logo_out = data.token_logo_out;
        this.token_amount_out = data.token_amount_out;
        this.amount_out_usd = data.amount_out_usd;
        this.pretty_amount_out_usd = data.pretty_amount_out_usd;
        this.borrow_rate_mode = data.borrow_rate_mode;
        this.borrow_rate = data.borrow_rate;
        this.on_behalf_of = data.on_behalf_of;
        this.liquidator = data.liquidator;
        this.user = data.user;
    }
}
class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param(itemData)) : null;
    }
}
class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
}
class TransactionsBlockResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
}
class TransactionsSummaryResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TransactionsSummary(itemData)) : null;
    }
}
class TransactionsSummary {
    constructor(data) {
        this.total_count = data.total_count;
        this.earliest_transaction = data.earliest_transaction && data.earliest_transaction !== null ? new TransactionSummary(data.earliest_transaction) : null;
        this.latest_transaction = data.latest_transaction && data.latest_transaction !== null ? new TransactionSummary(data.latest_transaction) : null;
    }
}
class TransactionSummary {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.tx_detail_link = data.tx_detail_link;
    }
}
/**
 * Transactions APIs
 *
 */
async function* paginateEndpoint(url, apiKey, urlsParams, debug, threadCount) {
    let hasNext = true;
    let response;
    let data;
    const backoff = new ExponentialBackoff(apiKey, debug);
    const LIMIT = pLimit$1(threadCount);
    while (hasNext) {
        try {
            let startTime;
            if (debug) {
                startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
            }
            response = await LIMIT(() => fetch(`${url}?${urlsParams}`, {
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "X-Requested-With": userAgent
                }
            }));
            debugOutput(response.url, response.status, startTime);
            if (response.status === 429) {
                try {
                    data = await LIMIT(() => backoff.backOff(response.url));
                }
                catch (error) {
                    hasNext = false;
                    throw new Error(`An error occurred ${response.status}: ${error.message}`);
                }
            }
            else {
                data = await response.json();
            }
            for (const tx of data.data.items) {
                const dataClass = new Transaction(tx);
                checkAndModifyResponse(dataClass);
                yield dataClass;
            }
            backoff.setNumAttempts(1);
            if (!data.error) {
                if ((data.data !== null) && data.data.links.prev === null) {
                    hasNext = false;
                }
                url = data.data !== null ? data.data.links.prev : "";
            }
            else {
                hasNext = false;
            }
        }
        catch (error) {
            hasNext = false;
            if (error.message.includes("An error occurred 429")) {
                throw new Error(error.message);
            }
            throw new Error(`An error occurred ${data ? data.error_code : response.status}: ${data ? data.error_message : "401 Authorization Required"}`);
        }
    }
}
class TransactionService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch and render a single transaction including its decoded log events. Additionally return semantically decoded information for DEX trades, lending and NFT sales.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} txHash - The transaction hash.
     * @param {GetTransactionQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withDex`: Decoded DEX details including protocol (e.g. Uniswap), event (e.g 'add_liquidity') and tokens involved with historical prices. Additional 0.05 credits charged if data available.
     *   - `withNftSales`: Decoded NFT sales details including marketplace (e.g. Opensea) and cached media links. Additional 0.05 credits charged if data available.
     *   - `withLending`: Decoded lending details including protocol (e.g. Aave), event (e.g. 'deposit') and tokens involved with prices. Additional 0.05 credits charged if data available.
     *
     */
    async getTransaction(chainName, txHash, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withDex !== undefined) {
                    urlParams.append("with-dex", queryParamOpts?.withDex.toString());
                }
                if (queryParamOpts?.withNftSales !== undefined) {
                    urlParams.append("with-nft-sales", queryParamOpts?.withNftSales.toString());
                }
                if (queryParamOpts?.withLending !== undefined) {
                    urlParams.append("with-lending", queryParamOpts?.withLending.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/transaction_v2/${txHash}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the most recent transactions involving an address. Frequently seen in wallet applications.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAllTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *
     */
    async *getAllTransactionsForAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let tx;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.blockSignedAtAsc !== undefined) {
                    urlParams.append("block-signed-at-asc", queryParamOpts?.blockSignedAtAsc.toString());
                }
                for await (tx of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/`, this.apiKey, urlParams, this.debug, this.threadCount)) {
                    yield tx;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {number} blockHeight - The requested block height.
     * @param {GetTransactionsForBlockQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *
     */
    async getTransactionsForBlock(chainName, blockHeight, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block/${blockHeight}/transactions_v3/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch the earliest and latest transactions, and the transaction count for a wallet. Calculate the age of the wallet and the time it has been idle and quickly gain insights into their engagement with web3.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTransactionSummary(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_summary/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsSummaryResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}

class PoolResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Pool(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class Pool {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class Token {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.volume_in_24h = data.volume_in_24h;
        this.volume_out_24h = data.volume_out_24h;
        this.quote_rate = data.quote_rate;
        this.reserve = data.reserve;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.volume_in_7d = data.volume_in_7d;
        this.volume_out_7d = data.volume_out_7d;
    }
}
class PoolToDexResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolToDexItem(itemData)) : null;
    }
}
class SupportedDex {
    constructor(data) {
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.dex_name = data.dex_name;
        this.factory_contract_address = data.factory_contract_address;
        this.router_contract_addresses = data.router_contract_addresses;
        this.swap_fee = data.swap_fee;
    }
}
class PoolToDexItem extends SupportedDex {
    constructor(data) {
        super(data);
        this.logo_url = data.logo_url;
    }
}
class PoolByAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolWithTimeseries {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.token_0_reserve_quote = data.token_0_reserve_quote;
        this.token_1_reserve_quote = data.token_1_reserve_quote;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
        this.volume_timeseries_7d = data.volume_timeseries_7d && data.volume_timeseries_7d !== null ? data.volume_timeseries_7d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.volume_timeseries_30d = data.volume_timeseries_30d && data.volume_timeseries_30d !== null ? data.volume_timeseries_30d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.liquidity_timeseries_7d = data.liquidity_timeseries_7d && data.liquidity_timeseries_7d !== null ? data.liquidity_timeseries_7d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.liquidity_timeseries_30d = data.liquidity_timeseries_30d && data.liquidity_timeseries_30d !== null ? data.liquidity_timeseries_30d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.price_timeseries_7d = data.price_timeseries_7d && data.price_timeseries_7d !== null ? data.price_timeseries_7d.map((itemData) => new PriceTimeseries(itemData)) : null;
        this.price_timeseries_30d = data.price_timeseries_30d && data.price_timeseries_30d !== null ? data.price_timeseries_30d.map((itemData) => new PriceTimeseries(itemData)) : null;
    }
}
class VolumeTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt;
        this.exchange = data.exchange;
        this.sum_amount_0_in = data.sum_amount_0_in;
        this.sum_amount_0_out = data.sum_amount_0_out;
        this.sum_amount_1_in = data.sum_amount_1_in;
        this.sum_amount_1_out = data.sum_amount_1_out;
        this.volume_quote = data.volume_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt;
        this.exchange = data.exchange;
        this.r0_c = data.r0_c;
        this.r1_c = data.r1_c;
        this.liquidity_quote = data.liquidity_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
    }
}
class PriceTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt;
        this.exchange = data.exchange;
        this.price_of_token_0_in_token_1 = data.price_of_token_0_in_token_1;
        this.price_of_token_0_in_token_1_description = data.price_of_token_0_in_token_1_description;
        this.price_of_token_1_in_token_0 = data.price_of_token_1_in_token_0;
        this.price_of_token_1_in_token_0_description = data.price_of_token_1_in_token_0_description;
        this.quote_currency = data.quote_currency;
        this.price_of_token_0_in_quote_currency = data.price_of_token_0_in_quote_currency;
        this.price_of_token_1_in_quote_currency = data.price_of_token_1_in_quote_currency;
    }
}
class PoolsDexDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolsDexDataItem(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolsDexDataItem {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.exchange = data.exchange;
        this.exchange_ticker_symbol = data.exchange_ticker_symbol;
        this.exchange_logo_url = data.exchange_logo_url;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.volume_7d_quote = data.volume_7d_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolsDexToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolsDexToken(data.token_1) : null;
    }
}
class PoolsDexToken {
    constructor(data) {
        this.reserve = data.reserve;
        this.contract_name = data.contract_name;
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
    }
}
class AddressExchangeBalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeBalanceItem(itemData)) : null;
    }
}
class UniswapLikeBalanceItem {
    constructor(data) {
        this.token_0 = data.token_0 && data.token_0 !== null ? new UniswapLikeToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new UniswapLikeToken(data.token_1) : null;
        this.pool_token = data.pool_token && data.pool_token !== null ? new UniswapLikeTokenWithSupply(data.pool_token) : null;
    }
}
class UniswapLikeToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.quote_rate = data.quote_rate;
    }
}
class UniswapLikeTokenWithSupply {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.quote_rate = data.quote_rate;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
    }
}
class NetworkExchangeTokensResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenV2Volume(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TokenV2Volume {
    constructor(data) {
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.total_liquidity = data.total_liquidity;
        this.total_volume24h = data.total_volume24h;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.swap_count_24h = data.swap_count_24h;
        this.quote_rate = data.quote_rate;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.total_volume_24h_quote = data.total_volume_24h_quote;
    }
}
class SupportedDexesResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new SupportedDex(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class SingleNetworkExchangeTokenResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForAccountAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class ExchangeTransaction {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.act = data.act;
        this.address = data.address;
        this.amount0 = data.amount0;
        this.amount1 = data.amount1;
        this.amount0_in = data.amount0_in;
        this.amount0_out = data.amount0_out;
        this.amount1_out = data.amount1_out;
        this.to_address = data.to_address;
        this.from_address = data.from_address;
        this.sender_address = data.sender_address;
        this.total_quote = data.total_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolToken(data.token_1) : null;
    }
}
class PoolToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class TransactionsForTokenAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForExchangeResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class EcosystemChartDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeEcosystemCharts(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class UniswapLikeEcosystemCharts {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.quote_currency = data.quote_currency;
        this.gas_token_price_quote = data.gas_token_price_quote;
        this.total_swaps24h = data.total_swaps24h;
        this.total_active_pairs7d = data.total_active_pairs7d;
        this.total_fees24h = data.total_fees24h;
        this.volume_chart7d = data.volume_chart7d && data.volume_chart7d !== null ? data.volume_chart7d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.volume_chart30d = data.volume_chart30d && data.volume_chart30d !== null ? data.volume_chart30d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.liquidity_chart7d = data.liquidity_chart7d && data.liquidity_chart7d !== null ? data.liquidity_chart7d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
        this.liquidity_chart30d = data.liquidity_chart30d && data.liquidity_chart30d !== null ? data.liquidity_chart30d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
    }
}
class VolumeEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.volume_quote = data.volume_quote;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.liquidity_quote = data.liquidity_quote;
    }
}
class HealthDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new HealthData(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class HealthData {
    constructor(data) {
        this.synced_block_height = data.synced_block_height;
        this.synced_block_signed_at = data.synced_block_signed_at && data.synced_block_signed_at !== null ? parseISO(data.synced_block_signed_at.toString()) : null;
        this.latest_block_height = data.latest_block_height;
        this.latest_block_signed_at = data.latest_block_signed_at && data.latest_block_signed_at !== null ? parseISO(data.latest_block_signed_at.toString()) : null;
    }
}
/**
 * XYK APIs
 *
 */
class XykService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to get all the pools of a particular DEX. Supports most common DEXs (Uniswap, SushiSwap, etc), and returns detailed trading data (volume, liquidity, swap counts, fees, LP token prices).
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getPools(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the corresponding supported DEX given a pool address, along with the swap fees, DEX's logo url, and factory addresses. Useful to identifying the specific DEX to which a pair address is associated.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} poolAddress - The requested pool address.
     *
     */
    async getDexForPoolAddress(chainName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${poolAddress}/dex_name/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolToDexResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the 7 day and 30 day time-series data (volume, liquidity, price) of a particular liquidity pool in a DEX. Useful for building time-series charts on DEX trading activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getPoolByAddress(chainName, dexName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolByAddressResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and the supported DEX for a token. Useful for building a table of top pairs across all supported DEXes that the token is trading on.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForTokenAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getPoolsForTokenAddress(chainName, tokenAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/tokens/address/${tokenAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to return balance of a wallet/contract address on a specific DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address.
     *
     */
    async getAddressExchangeBalances(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/balances/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AddressExchangeBalancesResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and supported DEX for a wallet. Useful for building a personal DEX UI showcasing pairs and supported DEXes associated to the wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The account address.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForWalletAddressQueryParamOpts} queryParamOpts
     *   - `tokenAddress`: The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getPoolsForWalletAddress(chainName, walletAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.tokenAddress !== undefined) {
                    urlParams.append("token-address", queryParamOpts?.tokenAddress.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${walletAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to retrieve all network exchange tokens for a specific DEX. Useful for building a top tokens table by total liquidity within a particular DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getNetworkExchangeTokens(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkExchangeTokensResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the supported DEXs available for the xy=k endpoints, along with the swap fees and factory addresses.
     *
     *
     */
    async getSupportedDEXes() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/xy=k/supported_dexes/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SupportedDexesResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get historical daily swap count for a single network exchange token.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getSingleNetworkExchangeToken(chainName, dexName, tokenAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SingleNetworkExchangeTokenResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the DEX transactions of a wallet. Useful for building tables of DEX activity segmented by wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address. Passing in an `ENS` or `RNS` resolves automatically.
     *
     */
    async getTransactionsForAccountAddress(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForAccountAddressResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the transactions of a token within a particular DEX. Useful for getting a per-token view of DEX activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTransactionsForTokenAddress(chainName, dexName, tokenAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForTokenAddressResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used for getting all the transactions of a particular DEX liquidity pool. Useful for building a transactions history table for an individual pool.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTransactionsForExchange(chainName, dexName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForExchangeResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a 7d and 30d time-series chart of DEX activity. Includes volume and swap count.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getEcosystemChartData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/ecosystem/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new EcosystemChartDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to ping the health of xy=k endpoints to get the synced block height per chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getHealthData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/health/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new HealthDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}

const userAgent = "com.covalenthq.sdk.typescript/0.4.2";
/**
 * CovalentClient Class
 */
class CovalentClient {
    constructor(apiKey, settings) {
        const { debug = false, threadCount = 3 } = settings || {};
        this.SecurityService = new SecurityService(apiKey, debug, threadCount);
        this.BalanceService = new BalanceService(apiKey, debug, threadCount);
        this.BaseService = new BaseService(apiKey, debug, threadCount);
        this.NftService = new NftService(apiKey, debug, threadCount);
        this.PricingService = new PricingService(apiKey, debug, threadCount);
        this.TransactionService = new TransactionService(apiKey, debug, threadCount);
        this.XykService = new XykService(apiKey, debug, threadCount);
    }
}
/**
 * @deprecated
 * Please use {@link CovalentClient} going forward! This method will be removed after Oct 31, 2023.
 * @see #CovalentClient
 * CovalentClient Class
 */
class Client {
    constructor(apiKey, settings) {
        const { debug = false, threadCount = 3 } = settings || {};
        this.SecurityService = new SecurityService(apiKey, debug, threadCount);
        this.BalanceService = new BalanceService(apiKey, debug, threadCount);
        this.BaseService = new BaseService(apiKey, debug, threadCount);
        this.NftService = new NftService(apiKey, debug, threadCount);
        this.PricingService = new PricingService(apiKey, debug, threadCount);
        this.TransactionService = new TransactionService(apiKey, debug, threadCount);
        this.XykService = new XykService(apiKey, debug, threadCount);
    }
}

export { Client, CovalentClient };
//# sourceMappingURL=index.js.map
