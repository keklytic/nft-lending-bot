import { userAgent } from "./CovalentClient";
import { checkAndModifyResponse, debugOutput, paginateEndpoint } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
class BlockResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Block(itemData)) : null;
    }
}
class Block {
    constructor(data) {
        this.signed_at = data.signed_at && data.signed_at !== null ? parseISO(data.signed_at.toString()) : null;
        this.height = data.height;
    }
}
class ResolvedAddress {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ResolvedAddressItem(itemData)) : null;
    }
}
class ResolvedAddressItem {
    constructor(data) {
        this.address = data.address;
        this.name = data.name;
    }
}
class BlockHeightsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Block(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class GetLogsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new GetLogsEvent(itemData)) : null;
    }
}
class GetLogsEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param(itemData)) : null;
    }
}
class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
}
class LogEventsByAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new LogEvent(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class LogEventsByTopicHashResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new LogEvent(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class AllChainsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainItem(itemData)) : null;
    }
}
class ChainItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.db_schema_name = data.db_schema_name;
        this.label = data.label;
        this.category_label = data.category_label;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.appchain_of = data.appchain_of && data.appchain_of !== null ? new ChainItem(data.appchain_of) : null;
    }
}
class AllChainsStatusResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainStatusItem(itemData)) : null;
    }
}
class ChainStatusItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.synced_block_height = data.synced_block_height;
        this.synced_blocked_signed_at = data.synced_blocked_signed_at && data.synced_blocked_signed_at !== null ? parseISO(data.synced_blocked_signed_at.toString()) : null;
        this.has_data = data.has_data;
    }
}
class ChainActivityResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainActivityEvent(itemData)) : null;
    }
}
class ChainActivityEvent extends ChainItem {
    constructor(data) {
        super(data);
        this.last_seen_at = data.last_seen_at && data.last_seen_at !== null ? parseISO(data.last_seen_at.toString()) : null;
    }
}
/**
 * Class A - Base
 *
 */
export class BaseService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch and render a single block for a block explorer.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHeight - The block height or `latest` for the latest block available.
     *
     */
    async getBlock(chainName, blockHeight) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_v2/${blockHeight}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BlockResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to resolve ENS, RNS and Unstoppable Domains addresses.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getResolvedAddress(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/resolve_address/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ResolvedAddress(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getBlockHeights(chainName, startDate, endDate, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/`, this.apiKey, urlParams, Block, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs of the latest block, or for a range of blocks. Includes sender contract metadata as well as decoded logs.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetLogsQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `address`: The address of the log events sender contract.
     *   - `topics`: The topic hash(es) to retrieve logs with.
     *   - `blockHash`: The block hash to retrieve logs for.
     *   - `skipDecode`: Omit decoded log events.
     *
     */
    async getLogs(chainName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.address !== undefined) {
                    urlParams.append("address", queryParamOpts?.address.toString());
                }
                if (queryParamOpts?.topics !== undefined) {
                    urlParams.append("topics", queryParamOpts?.topics.toString());
                }
                if (queryParamOpts?.blockHash !== undefined) {
                    urlParams.append("block-hash", queryParamOpts?.blockHash.toString());
                }
                if (queryParamOpts?.skipDecode !== undefined) {
                    urlParams.append("skip-decode", queryParamOpts?.skipDecode.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new GetLogsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByAddress(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/`, this.apiKey, urlParams, LogEvent, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByTopicHash(chainName, topicHash, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.secondaryTopics !== undefined) {
                    urlParams.append("secondary-topics", queryParamOpts?.secondaryTopics.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/`, this.apiKey, urlParams, LogEvent, this.debug, this.threadCount)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to build internal dashboards for all supported chains on Covalent.
     *
     *
     */
    async getAllChains() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build internal status dashboards of all supported chains.
     *
     *
     */
    async getAllChainStatus() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/status/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsStatusResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to locate chains which an address is active on with a single API call.
     *
     * @param {string} walletAddress - The requested wallet address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAddressActivityQueryParamOpts} queryParamOpts
     *   - `testnets`: Set to true to include testnets with activity in the response. By default, it's set to `false` and only returns mainnet activity.
     *
     */
    async getAddressActivity(walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.testnets !== undefined) {
                    urlParams.append("testnets", queryParamOpts?.testnets.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/address/${walletAddress}/activity/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ChainActivityResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=BaseService.js.map