import { userAgent } from "./CovalentClient";
import { checkAndModifyResponse, debugOutput } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
class ApprovalsResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokensApprovalItem(itemData)) : null;
    }
}
class TokensApprovalItem {
    constructor(data) {
        this.token_address = data.token_address;
        this.token_address_label = data.token_address_label;
        this.ticker_symbol = data.ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_quote = data.balance_quote;
        this.pretty_balance_quote = data.pretty_balance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.spenders = data.spenders && data.spenders !== null ? data.spenders.map((itemData) => new TokenSpenderItem(itemData)) : null;
    }
}
class TokenSpenderItem {
    constructor(data) {
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.spender_address = data.spender_address;
        this.spender_address_label = data.spender_address_label;
        this.allowance = data.allowance;
        this.allowance_quote = data.allowance_quote;
        this.pretty_allowance_quote = data.pretty_allowance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.risk_factor = data.risk_factor;
    }
}
/**
 * Approvals API
 *
 */
export class SecurityService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to get a list of approvals across all token contracts categorized by spenders for a walletâ€™s assets.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getApprovals(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/approvals/${walletAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ApprovalsResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=SecurityService.js.map