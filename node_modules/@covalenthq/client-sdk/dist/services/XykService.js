import { userAgent } from "./CovalentClient";
import { checkAndModifyResponse, debugOutput } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
class PoolResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Pool(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class Pool {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class Token {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.volume_in_24h = data.volume_in_24h;
        this.volume_out_24h = data.volume_out_24h;
        this.quote_rate = data.quote_rate;
        this.reserve = data.reserve;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.volume_in_7d = data.volume_in_7d;
        this.volume_out_7d = data.volume_out_7d;
    }
}
class PoolToDexResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolToDexItem(itemData)) : null;
    }
}
class SupportedDex {
    constructor(data) {
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.dex_name = data.dex_name;
        this.factory_contract_address = data.factory_contract_address;
        this.router_contract_addresses = data.router_contract_addresses;
        this.swap_fee = data.swap_fee;
    }
}
class PoolToDexItem extends SupportedDex {
    constructor(data) {
        super(data);
        this.logo_url = data.logo_url;
    }
}
class PoolByAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolWithTimeseries {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.token_0_reserve_quote = data.token_0_reserve_quote;
        this.token_1_reserve_quote = data.token_1_reserve_quote;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
        this.volume_timeseries_7d = data.volume_timeseries_7d && data.volume_timeseries_7d !== null ? data.volume_timeseries_7d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.volume_timeseries_30d = data.volume_timeseries_30d && data.volume_timeseries_30d !== null ? data.volume_timeseries_30d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.liquidity_timeseries_7d = data.liquidity_timeseries_7d && data.liquidity_timeseries_7d !== null ? data.liquidity_timeseries_7d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.liquidity_timeseries_30d = data.liquidity_timeseries_30d && data.liquidity_timeseries_30d !== null ? data.liquidity_timeseries_30d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.price_timeseries_7d = data.price_timeseries_7d && data.price_timeseries_7d !== null ? data.price_timeseries_7d.map((itemData) => new PriceTimeseries(itemData)) : null;
        this.price_timeseries_30d = data.price_timeseries_30d && data.price_timeseries_30d !== null ? data.price_timeseries_30d.map((itemData) => new PriceTimeseries(itemData)) : null;
    }
}
class VolumeTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt;
        this.exchange = data.exchange;
        this.sum_amount_0_in = data.sum_amount_0_in;
        this.sum_amount_0_out = data.sum_amount_0_out;
        this.sum_amount_1_in = data.sum_amount_1_in;
        this.sum_amount_1_out = data.sum_amount_1_out;
        this.volume_quote = data.volume_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt;
        this.exchange = data.exchange;
        this.r0_c = data.r0_c;
        this.r1_c = data.r1_c;
        this.liquidity_quote = data.liquidity_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
    }
}
class PriceTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt;
        this.exchange = data.exchange;
        this.price_of_token_0_in_token_1 = data.price_of_token_0_in_token_1;
        this.price_of_token_0_in_token_1_description = data.price_of_token_0_in_token_1_description;
        this.price_of_token_1_in_token_0 = data.price_of_token_1_in_token_0;
        this.price_of_token_1_in_token_0_description = data.price_of_token_1_in_token_0_description;
        this.quote_currency = data.quote_currency;
        this.price_of_token_0_in_quote_currency = data.price_of_token_0_in_quote_currency;
        this.price_of_token_1_in_quote_currency = data.price_of_token_1_in_quote_currency;
    }
}
class PoolsDexDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolsDexDataItem(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolsDexDataItem {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.exchange = data.exchange;
        this.exchange_ticker_symbol = data.exchange_ticker_symbol;
        this.exchange_logo_url = data.exchange_logo_url;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.volume_7d_quote = data.volume_7d_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolsDexToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolsDexToken(data.token_1) : null;
    }
}
class PoolsDexToken {
    constructor(data) {
        this.reserve = data.reserve;
        this.contract_name = data.contract_name;
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
    }
}
class AddressExchangeBalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeBalanceItem(itemData)) : null;
    }
}
class UniswapLikeBalanceItem {
    constructor(data) {
        this.token_0 = data.token_0 && data.token_0 !== null ? new UniswapLikeToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new UniswapLikeToken(data.token_1) : null;
        this.pool_token = data.pool_token && data.pool_token !== null ? new UniswapLikeTokenWithSupply(data.pool_token) : null;
    }
}
class UniswapLikeToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.quote_rate = data.quote_rate;
    }
}
class UniswapLikeTokenWithSupply {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.quote_rate = data.quote_rate;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
    }
}
class NetworkExchangeTokensResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenV2Volume(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TokenV2Volume {
    constructor(data) {
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.total_liquidity = data.total_liquidity;
        this.total_volume24h = data.total_volume24h;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.swap_count_24h = data.swap_count_24h;
        this.quote_rate = data.quote_rate;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.total_volume_24h_quote = data.total_volume_24h_quote;
    }
}
class SupportedDexesResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new SupportedDex(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class SingleNetworkExchangeTokenResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForAccountAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class ExchangeTransaction {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.act = data.act;
        this.address = data.address;
        this.amount0 = data.amount0;
        this.amount1 = data.amount1;
        this.amount0_in = data.amount0_in;
        this.amount0_out = data.amount0_out;
        this.amount1_out = data.amount1_out;
        this.to_address = data.to_address;
        this.from_address = data.from_address;
        this.sender_address = data.sender_address;
        this.total_quote = data.total_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolToken(data.token_1) : null;
    }
}
class PoolToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class TransactionsForTokenAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForExchangeResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class EcosystemChartDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeEcosystemCharts(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class UniswapLikeEcosystemCharts {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.quote_currency = data.quote_currency;
        this.gas_token_price_quote = data.gas_token_price_quote;
        this.total_swaps24h = data.total_swaps24h;
        this.total_active_pairs7d = data.total_active_pairs7d;
        this.total_fees24h = data.total_fees24h;
        this.volume_chart7d = data.volume_chart7d && data.volume_chart7d !== null ? data.volume_chart7d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.volume_chart30d = data.volume_chart30d && data.volume_chart30d !== null ? data.volume_chart30d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.liquidity_chart7d = data.liquidity_chart7d && data.liquidity_chart7d !== null ? data.liquidity_chart7d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
        this.liquidity_chart30d = data.liquidity_chart30d && data.liquidity_chart30d !== null ? data.liquidity_chart30d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
    }
}
class VolumeEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.volume_quote = data.volume_quote;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.liquidity_quote = data.liquidity_quote;
    }
}
class HealthDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new HealthData(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class HealthData {
    constructor(data) {
        this.synced_block_height = data.synced_block_height;
        this.synced_block_signed_at = data.synced_block_signed_at && data.synced_block_signed_at !== null ? parseISO(data.synced_block_signed_at.toString()) : null;
        this.latest_block_height = data.latest_block_height;
        this.latest_block_signed_at = data.latest_block_signed_at && data.latest_block_signed_at !== null ? parseISO(data.latest_block_signed_at.toString()) : null;
    }
}
/**
 * XYK APIs
 *
 */
export class XykService {
    constructor(apiKey, debug = false, threadCount = 3) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to get all the pools of a particular DEX. Supports most common DEXs (Uniswap, SushiSwap, etc), and returns detailed trading data (volume, liquidity, swap counts, fees, LP token prices).
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getPools(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the corresponding supported DEX given a pool address, along with the swap fees, DEX's logo url, and factory addresses. Useful to identifying the specific DEX to which a pair address is associated.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} poolAddress - The requested pool address.
     *
     */
    async getDexForPoolAddress(chainName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${poolAddress}/dex_name/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolToDexResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the 7 day and 30 day time-series data (volume, liquidity, price) of a particular liquidity pool in a DEX. Useful for building time-series charts on DEX trading activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getPoolByAddress(chainName, dexName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolByAddressResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and the supported DEX for a token. Useful for building a table of top pairs across all supported DEXes that the token is trading on.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForTokenAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getPoolsForTokenAddress(chainName, tokenAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/tokens/address/${tokenAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to return balance of a wallet/contract address on a specific DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address.
     *
     */
    async getAddressExchangeBalances(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/balances/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AddressExchangeBalancesResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and supported DEX for a wallet. Useful for building a personal DEX UI showcasing pairs and supported DEXes associated to the wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The account address.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForWalletAddressQueryParamOpts} queryParamOpts
     *   - `tokenAddress`: The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getPoolsForWalletAddress(chainName, walletAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.tokenAddress !== undefined) {
                    urlParams.append("token-address", queryParamOpts?.tokenAddress.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${walletAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to retrieve all network exchange tokens for a specific DEX. Useful for building a top tokens table by total liquidity within a particular DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getNetworkExchangeTokens(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkExchangeTokensResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the supported DEXs available for the xy=k endpoints, along with the swap fees and factory addresses.
     *
     *
     */
    async getSupportedDEXes() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/xy=k/supported_dexes/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SupportedDexesResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get historical daily swap count for a single network exchange token.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getSingleNetworkExchangeToken(chainName, dexName, tokenAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SingleNetworkExchangeTokenResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the DEX transactions of a wallet. Useful for building tables of DEX activity segmented by wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address. Passing in an `ENS` or `RNS` resolves automatically.
     *
     */
    async getTransactionsForAccountAddress(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForAccountAddressResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the transactions of a token within a particular DEX. Useful for getting a per-token view of DEX activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTransactionsForTokenAddress(chainName, dexName, tokenAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForTokenAddressResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used for getting all the transactions of a particular DEX liquidity pool. Useful for building a transactions history table for an individual pool.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTransactionsForExchange(chainName, dexName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForExchangeResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a 7d and 30d time-series chart of DEX activity. Includes volume and swap count.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getEcosystemChartData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/ecosystem/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new EcosystemChartDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to ping the health of xy=k endpoints to get the synced block height per chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getHealthData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                let startTime;
                if (this.debug) {
                    startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/health/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": userAgent
                    }
                }));
                debugOutput(response.url, response.status, startTime);
                if (response.status === 429) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response.url));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new HealthDataResponse(data.data);
                checkAndModifyResponse(dataClass);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=XykService.js.map