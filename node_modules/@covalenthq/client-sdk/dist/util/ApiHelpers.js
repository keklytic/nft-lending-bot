import { ExponentialBackoff } from "./backoff";
import { userAgent } from "../services/CovalentClient";
import chalk from "chalk";
import pLimit from "p-limit";
export function checkAndModifyResponse(jsonObj) {
    for (const key in jsonObj) {
        if (key === 'next_update_at') {
            delete jsonObj[key];
        }
        else if (typeof jsonObj[key] === 'object') {
            checkAndModifyResponse(jsonObj[key]);
        }
    }
}
export async function debugOutput(url, responseStatus, startTime) {
    let endTime;
    let elapsedTime;
    if (startTime === undefined) {
        return;
    }
    if (typeof startTime !== 'number') {
        endTime = process.hrtime(startTime);
        elapsedTime = (endTime[0] * 1000 + endTime[1] / 1e6);
    }
    else {
        endTime = performance.now();
        elapsedTime = endTime - startTime;
    }
    console.log(`${chalk.red("[DEBUG]")}` + " |" + ` Request URL: ${chalk.yellow(url)}` + " |" + ` Response code: ${responseStatus !== 200 ? chalk.red(responseStatus) : chalk.green(responseStatus)}` + " |" + ` Response time: ${chalk.cyan(elapsedTime.toFixed(2) + "ms")}`);
}
export async function* paginateEndpoint(url, apiKey, urlsParams, dataClassConstructor, debug, threadCount) {
    let hasNext = true;
    let response;
    let data;
    const backoff = new ExponentialBackoff(apiKey, debug);
    let page_number = 0;
    const LIMIT = pLimit(threadCount);
    while (hasNext) {
        try {
            let startTime;
            if (debug) {
                startTime = typeof performance !== 'undefined' ? performance.now() : process.hrtime();
            }
            response = await LIMIT(() => fetch(urlsParams.get("page-number") ? `${url}?${urlsParams}` : `${url}?${urlsParams}&page-number=${page_number}`, {
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "X-Requested-With": userAgent
                }
            }));
            debugOutput(response.url, response.status, startTime);
            if (response.status === 429) {
                try {
                    data = await LIMIT(() => backoff.backOff(response.url));
                }
                catch (error) {
                    hasNext = false;
                    throw new Error(`An error occurred ${response.status}: ${error.message}`);
                }
            }
            else {
                data = await response.json();
            }
            for (const tx of data.data.items) {
                const dataClass = new dataClassConstructor(tx);
                checkAndModifyResponse(dataClass);
                yield dataClass;
            }
            backoff.setNumAttempts(1);
            if (!data.error) {
                if ((data.data !== null) && data.data.pagination !== null && data.data.pagination.has_more === false) {
                    hasNext = false;
                }
                if (urlsParams.get("page-number")) {
                    const next_page = parseInt(urlsParams.get("page-number")) + 1;
                    urlsParams.set("page-number", next_page.toString());
                }
                else {
                    page_number = page_number + 1;
                }
            }
            else {
                hasNext = false;
            }
        }
        catch (error) {
            hasNext = false;
            if (error.message.includes("An error occurred 429")) {
                throw new Error(error.message);
            }
            throw new Error(`An error occurred ${data ? data.error_code : response.status}: ${data ? data.error_message : "401 Authorization Required"}`);
        }
    }
}
//# sourceMappingURL=ApiHelpers.js.map